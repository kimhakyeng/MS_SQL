USE [PortfolioDB]
GO
/****** Object:  StoredProcedure [dbo].[P_GET_XMLDATA]    Script Date: 2023-10-12 오후 3:33:29 ******/
SET ANSI_NULLS ON
GO
SET QUOTED_IDENTIFIER ON
GO

ALTER PROCEDURE [dbo].[P_GET_XMLDATA]
	@IN_TABLE_NAME	NVARCHAR(50),
	@IN_XML	NVARCHAR(MAX) --XML
AS

--테이블 반환 매개 변수 찾아볼 것!!! => 이게 더 현실적으로 맞을 것 같음.

DECLARE @IDOC INT
DECLARE @COLUMN_SCHEMA NVARCHAR(4000)
SET @COLUMN_SCHEMA = ''

SELECT @COLUMN_SCHEMA = @COLUMN_SCHEMA + C.NAME + ' ' + UPPER(TYPE_NAME(C.XUSERTYPE))
	+ CASE WHEN UPPER(TYPE_NAME(XUSERTYPE)) IN ('DECIMAL','NUMERIC') THEN '(' + CONVERT(NVARCHAR,C.XPREC) + ',' + CONVERT(NVARCHAR,C.XSCALE) + ')'
	       WHEN UPPER(TYPE_NAME(XUSERTYPE)) IN ('NCHAR','NVARCHAR') THEN '(' + CONVERT(NVARCHAR,C.LENGTH / 2) + ')'
	       WHEN UPPER(TYPE_NAME(XUSERTYPE)) IN ('CHAR','VARCHAR') THEN '(' + CONVERT(NVARCHAR,C.LENGTH) + ')'
	       ELSE '' END + ','
FROM TEMPDB..SYSOBJECTS T
	INNER JOIN TEMPDB..SYSCOLUMNS C ON (T.ID = C.ID)
WHERE T.ID = OBJECT_ID(@IN_TABLE_NAME) --@IN_TABLE_NAME)
AND T.XTYPE = 'U'
ORDER BY T.NAME, C.COLORDER

SET @COLUMN_SCHEMA = SUBSTRING(@COLUMN_SCHEMA, 1, LEN(@COLUMN_SCHEMA) - 1)

EXEC SP_XML_PREPAREDOCUMENT @IDOC OUTPUT, @IN_XML


DECLARE @EXE_QUERY NVARCHAR(MAX)
	,@TMP_STRING NVARCHAR(200)
	
SET @TMP_STRING = QUOTENAME('/ROOT/DATA','''')

SET @EXE_QUERY = 'SELECT * FROM OPENXML (@IDOC, ' + @TMP_STRING + ', 2) '
               + 'WITH(' + @COLUMN_SCHEMA + ')'
	
--SELECT @EXE_QUERY

EXEC SP_EXECUTESQL @EXE_QUERY, N'@IDOC INT', @IDOC; --이부분이 중요하네 ... @

EXEC SP_XML_REMOVEDOCUMENT @IDOC; --문서 핸들로 지정된 XML 문서의 내부 표현을 제거하고 문서 핸들을 무효로 만듭니다. 


RETURN

/* 사용 방법
 
DECLARE @XML_CONTENTS NVARCHAR(4000) -- 파라미터라고 생각!!!

SET @XML_CONTENTS = N'
<ROOT>
  <DATA>
    <INSP_CODE>C2F01</INSP_CODE>
    <D0010>2±1.0</D0010>
    <D0020>㎏/㎤</D0020>
    <D0030>1</D0030>
  </DATA>
  <DATA>
    <INSP_CODE>C2F02</INSP_CODE>
    <D0010>4.5±0.5</D0010>
    <D0020>㎥/hr</D0020>
    <D0030>2</D0030>
  </DATA>
  <DATA>
    <INSP_CODE>C2F03</INSP_CODE>
    <D0010>4±0.5</D0010>
    <D0020>㎏/㎤</D0020>
    <D0030>3</D0030>
  </DATA>
  <DATA>
    <INSP_CODE>C2F04-1</INSP_CODE>
    <D0010>-</D0010>
    <D0020>hr/min</D0020>
    <D0030>4</D0030>
  </DATA>
  <DATA>
    <INSP_CODE>C2F04-2</INSP_CODE>
    <D0010>-</D0010>
    <D0020>hr/min</D0020>
    <D0030>5</D0030>
  </DATA>
  <DATA>
    <INSP_CODE>C2F04-3</INSP_CODE>
    <D0010>60±5.0</D0010>
    <D0020>min</D0020>
    <D0030>6</D0030>
  </DATA>
  <DATA>
    <INSP_CODE>C2F05-1</INSP_CODE>
    <D0010>-</D0010>
    <D0020>hr/min</D0020>
    <D0030>7</D0030>
  </DATA>
  <DATA>
    <INSP_CODE>C2F05-2</INSP_CODE>
    <D0010>-</D0010>
    <D0020>hr/min</D0020>
    <D0030>8</D0030>
  </DATA>
  <DATA>
    <INSP_CODE>C2F05-3</INSP_CODE>
    <D0010>60±5.0</D0010>
    <D0020>min</D0020>
    <D0030>9</D0030>
  </DATA>
</ROOT>'

IF OBJECT_ID('tempdb..#XML_TABLE') IS NOT NULL
	DROP TABLE #XML_TABLE

CREATE TABLE #XML_TABLE
(
	INSP_CODE		NVARCHAR(10),
	D0010			NVARCHAR(50),
	D0020			NVARCHAR(50),
	D0030			NVARCHAR(50)
)

INSERT INTO #XML_TABLE
EXEC USP_GET_XMLDATA 'tempdb..#XML_TABLE', @XML_CONTENTS

SELECT * FROM #XML_TABLE
*/



